import Database from 'better-sqlite3';
import { DB_PATH } from '../../execution/db/setup.js';
import { Review } from './review-coordinator.js';
import { NotificationDispatcher } from '../../execution/notifications.js';
import * as fs from 'fs';
import * as path from 'path';

export interface Pattern {
    id: string;
    action_type: string;
    creator_agent: string;
    total_attempts: number;
    successful_reviews: number;
    avg_confidence: number;
    eligible_for_skip: boolean;
    skip_enabled: boolean;
    skip_suggested: boolean;
    last_review_at: string | null;
    confidences: number[];
}

export class LearningEngine {
    private db: Database.Database;
    private config: any;
    private notifier: NotificationDispatcher;

    constructor() {
        this.db = new Database(DB_PATH);
        this.notifier = new NotificationDispatcher();
        this.config = {
            min_successful_reviews: 10,
            min_confidence_avg: 0.9,
            confidence_increase_per_success: 0.05,
            confidence_decrease_per_failure: 0.15,
            suggest_skip_after_eligible_days: 7
        };
    }

    async recordReview(review: Review): Promise<void> {
        const patternId = `${review.type}_${review.creator}`;
        let pattern = await this.getPattern(patternId);

        if (!pattern) {
            pattern = await this.createPattern(review.type, review.creator);
        }

        pattern.total_attempts++;
        pattern.last_review_at = new Date().toISOString();

        if (review.status === 'approved' && review.confidence && review.confidence >= 80) {
            pattern.successful_reviews++;
            pattern.confidences.push(review.confidence);

            // Keep only last 20 confidences
            if (pattern.confidences.length > 20) {
                pattern.confidences = pattern.confidences.slice(-20);
            }

            pattern.avg_confidence = pattern.confidences.reduce((a, b) => a + b, 0) / pattern.confidences.length / 100;
        }

        // Check eligibility for auto-skip
        if (this.isEligibleForSkip(pattern) && !pattern.eligible_for_skip) {
            pattern.eligible_for_skip = true;
            console.log(`[Learning] Pattern ${patternId} is now eligible for auto-skip`);

            // Suggest auto-skip to dashboard
            if (!pattern.skip_suggested) {
                await this.suggestAutoSkip(pattern);
                pattern.skip_suggested = true;
            }
        }

        await this.savePattern(pattern);
    }

    async suggestAutoSkip(pattern: Pattern): Promise<void> {
        // Create suggestion file in dashboard
        const suggestionsDir = path.resolve(process.cwd(), '.dashboard/suggestions');
        if (!fs.existsSync(suggestionsDir)) {
            fs.mkdirSync(suggestionsDir, { recursive: true });
        }

        const avgReviewTimeMinutes = 15; // Approximate
        const content = `# ðŸ’¡ Auto-Skip Suggestion: ${pattern.creator_agent} â†’ ${pattern.action_type}

**Pattern ID**: ${pattern.id}  
**Status**: Eligible for Auto-Skip  
**Created**: ${new Date().toISOString()}

---

## Performance Summary

| Metric | Value |
|--------|-------|
| Successful Reviews | ${pattern.successful_reviews} |
| Total Attempts | ${pattern.total_attempts} |
| Success Rate | ${Math.round((pattern.successful_reviews / pattern.total_attempts) * 100)}% |
| Average Confidence | ${Math.round(pattern.avg_confidence * 100)}% |

---

## Benefits of Enabling Auto-Skip

âœ… Save ~${avgReviewTimeMinutes} minutes per ${pattern.action_type}  
âœ… Reduce review queue backlog  
âœ… Increase development velocity  

> Reviews can be re-enabled anytime if quality drops.

---

## Action Required

To enable auto-skip for this pattern, run:
\`\`\`
mcp.learning.enableAutoSkip('${pattern.id}')
\`\`\`

Or leave this file to ignore the suggestion.

---

*Auto-generated by Learning Engine*
`;

        fs.writeFileSync(path.join(suggestionsDir, `skip_${pattern.id}.md`), content);

        console.log(`[Learning] Created auto-skip suggestion for ${pattern.id}`);
    }

    private isEligibleForSkip(pattern: Pattern): boolean {
        return (
            pattern.successful_reviews >= this.config.min_successful_reviews &&
            pattern.avg_confidence >= this.config.min_confidence_avg &&
            pattern.total_attempts === pattern.successful_reviews
        );
    }

    async shouldSkipReview(actionType: string, creator: string): Promise<{ skip: boolean; reason?: string }> {
        const patternId = `${actionType}_${creator}`;
        const pattern = await this.getPattern(patternId);

        if (!pattern || !pattern.skip_enabled) {
            return { skip: false };
        }

        // Safety check: don't skip if it's been more than 7 days since last review
        if (pattern.last_review_at) {
            const daysSince = (Date.now() - new Date(pattern.last_review_at).getTime()) / (1000 * 60 * 60 * 24);
            if (daysSince > 7) {
                return { skip: false, reason: 'Pattern check: reviewing after 7 day gap' };
            }
        }

        return {
            skip: true,
            reason: `Auto-skip: ${pattern.successful_reviews} successful reviews, ${Math.round(pattern.avg_confidence * 100)}% avg confidence`
        };
    }

    async enableAutoSkip(patternId: string): Promise<void> {
        const pattern = await this.getPattern(patternId);
        if (!pattern) throw new Error(`Pattern not found: ${patternId}`);

        pattern.skip_enabled = true;
        await this.savePattern(pattern);
        console.log(`[Learning] Auto-skip enabled for ${patternId}`);
    }

    async adjustPatternConfidence(patternId: string, outcome: 'success' | 'failure'): Promise<void> {
        const pattern = await this.getPattern(patternId);
        if (!pattern) return;

        if (outcome === 'success') {
            pattern.avg_confidence = Math.min(1.0, pattern.avg_confidence + this.config.confidence_increase_per_success);
        } else {
            pattern.avg_confidence = Math.max(0.0, pattern.avg_confidence - this.config.confidence_decrease_per_failure);

            if (pattern.skip_enabled && pattern.avg_confidence < 0.8) {
                pattern.skip_enabled = false;
                console.log(`[Learning] Auto-skip disabled for ${patternId} due to low confidence`);
            }
        }

        await this.savePattern(pattern);
    }

    private async getPattern(id: string): Promise<Pattern | null> {
        const row = this.db.prepare('SELECT * FROM auto_skip_patterns WHERE id = ?').get(id) as any;
        if (!row) return null;

        return {
            id: row.id,
            action_type: row.action_type,
            creator_agent: row.creator_agent,
            total_attempts: row.total_attempts,
            successful_reviews: row.successful_reviews,
            avg_confidence: row.avg_confidence || 0,
            eligible_for_skip: Boolean(row.eligible_for_skip),
            skip_enabled: Boolean(row.skip_enabled),
            skip_suggested: Boolean(row.skip_suggested),
            last_review_at: row.last_review_at,
            confidences: JSON.parse(row.confidences_json || '[]')
        };
    }

    private async createPattern(actionType: string, creator: string): Promise<Pattern> {
        const id = `${actionType}_${creator}`;
        const pattern: Pattern = {
            id,
            action_type: actionType,
            creator_agent: creator,
            total_attempts: 0,
            successful_reviews: 0,
            avg_confidence: 0,
            eligible_for_skip: false,
            skip_enabled: false,
            skip_suggested: false,
            last_review_at: null,
            confidences: []
        };

        await this.savePattern(pattern);
        return pattern;
    }

    private async savePattern(pattern: Pattern): Promise<void> {
        const stmt = this.db.prepare(`
            INSERT OR REPLACE INTO auto_skip_patterns (
                id, action_type, creator_agent, total_attempts, successful_reviews,
                avg_confidence, eligible_for_skip, skip_enabled, skip_suggested,
                last_review_at, confidences_json
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);

        stmt.run(
            pattern.id,
            pattern.action_type,
            pattern.creator_agent,
            pattern.total_attempts,
            pattern.successful_reviews,
            pattern.avg_confidence,
            pattern.eligible_for_skip ? 1 : 0,
            pattern.skip_enabled ? 1 : 0,
            pattern.skip_suggested ? 1 : 0,
            pattern.last_review_at,
            JSON.stringify(pattern.confidences)
        );
    }

    async getEligiblePatterns(): Promise<Pattern[]> {
        const rows = this.db.prepare('SELECT * FROM auto_skip_patterns WHERE eligible_for_skip = 1 AND skip_enabled = 0').all() as any[];
        return rows.map(row => ({
            id: row.id,
            action_type: row.action_type,
            creator_agent: row.creator_agent,
            total_attempts: row.total_attempts,
            successful_reviews: row.successful_reviews,
            avg_confidence: row.avg_confidence || 0,
            eligible_for_skip: Boolean(row.eligible_for_skip),
            skip_enabled: Boolean(row.skip_enabled),
            skip_suggested: Boolean(row.skip_suggested),
            last_review_at: row.last_review_at,
            confidences: JSON.parse(row.confidences_json || '[]')
        }));
    }
}
